// C·∫•u h√¨nh API URL
const API_BASE_URL = 'http://172.16.1.6:5000';

class ApiService {
  constructor() {
    this.baseURL = API_BASE_URL;
    // ∆Øu ti√™n token m·ªõi, fallback v·ªÅ authToken c≈©
    this.token = localStorage.getItem('token') || localStorage.getItem('authToken');
  }

  setToken(token) {
    this.token = token;
    if (token) {
      localStorage.setItem('token', token); // S·ª≠ d·ª•ng key m·ªõi
      localStorage.setItem('authToken', token); // Gi·ªØ key c≈© cho compatibility
    } else {
      localStorage.removeItem('token');
      localStorage.removeItem('authToken');
    }
    console.log('üîë API Service token updated:', token ? 'YES' : 'NO');
  }

  // Method ƒë·ªÉ refresh token t·ª´ localStorage
  refreshToken() {
    const newToken = localStorage.getItem('token') || localStorage.getItem('authToken');
    if (newToken !== this.token) {
      this.token = newToken;
      console.log('üîÑ API Service token refreshed:', newToken ? 'YES' : 'NO');
    }
    return this.token;
  }

  // Helper method ƒë·ªÉ t·∫°o headers v·ªõi token
  getHeaders() {
    // T·ª± ƒë·ªông refresh token t·ª´ localStorage
    this.refreshToken();
    
    const headers = {
      'Content-Type': 'application/json',
      ...(this.token && { 'Authorization': `Bearer ${this.token}` })
    };
    
    console.log('üì§ Request headers:', { 
      hasAuth: !!headers.Authorization,
      tokenPreview: this.token ? this.token.substring(0, 20) + '...' : 'NO TOKEN'
    });
    
    return headers;
  }

  // Helper method ƒë·ªÉ x·ª≠ l√Ω response
  async handleResponse(response) {
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
    }
    return response.json();
  }

  async request(endpoint, options = {}) {
    // ƒê·∫£m b·∫£o endpoint lu√¥n c√≥ /api ph√≠a tr∆∞·ªõc
    let url = endpoint.startsWith('/api/') ? `${this.baseURL}${endpoint}` : `${this.baseURL}/api${endpoint}`;
    const config = {
      headers: {
        ...this.getHeaders(),
        ...options.headers
      },
      ...options
    };

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error("‚ùå Response error text:", errorText);
      }
      
      return this.handleResponse(response);
    } catch (error) {
      console.error("‚ùå Request error:", error);
      throw error;
    }
  }

  // Authentication
  async login(username, password) {
    const response = await fetch(`${this.baseURL}/api/login`, {
      method: 'POST',
      headers: this.getHeaders(),
      body: JSON.stringify({ username, password })
    });
    const data = await this.handleResponse(response);
    const token = data.data?.token || data.token;
    if (token) {
      this.setToken(token);
    }
    return data.data || data;
  }

  async logout() {
    try {
      // G·ªçi API logout t·ª´ backend
      await fetch(`${this.baseURL}/api/logout`, { 
        method: "POST", 
        headers: this.getHeaders(),
        credentials: "include" 
      });
    } catch (error) {
      console.log("Logout API call failed (this is normal):", error.message);
    }
    // Lu√¥n x√≥a token ·ªü client
    this.setToken(null);
  }

  async getProfile() {
    const response = await fetch(`${this.baseURL}/api/user/profile`, {
      headers: this.getHeaders()
    });
    const data = await this.handleResponse(response);
    return data.data || data;
  }

  // Tasks
  async getTasks() {
    return await this.request('/tasks');
  }

  async createTask(taskData) {
    return await this.request('/tasks', {
      method: 'POST',
      body: JSON.stringify(taskData)
    });
  }

  async updateTask(id, taskData) {
    return await this.request(`/tasks/${id}`, {
      method: 'PUT',
      body: JSON.stringify(taskData)
    });
  }

  async deleteTask(id) {
    return await this.request(`/tasks/${id}`, {
      method: 'DELETE'
    });
  }

  // Notifications
  async getNotifications() {
    return await this.request('/notifications');
  }

  async markNotificationAsRead(id) {
    return await this.request(`/notifications/${id}/read`, {
      method: 'PUT'
    });
  }

  // System
  async healthCheck() {
    const response = await fetch(`${this.baseURL}/api/health`);
    return this.handleResponse(response);
  }

  async initDemo() {
    const response = await fetch(`${this.baseURL}/api/init-demo`, {
      method: 'POST',
      headers: this.getHeaders()
    });
    return this.handleResponse(response);
  }

  // Users (T√†i kho·∫£n)
  async getUsers() {
    console.log("üîç api.getUsers() token check:", { 
      hasToken: !!this.token,
      tokenLength: this.token?.length,
      tokenStart: this.token?.substring(0, 20)
    });
    
    const data = await this.request('/users-all');
    console.log("üîç api.getUsers() raw response:", { 
      type: typeof data, 
      hasData: !!data?.data,
      isArray: Array.isArray(data),
      dataIsArray: Array.isArray(data?.data),
      keys: Object.keys(data || {}),
      success: data?.success,
      error: data?.error,
      dataContent: data
    });
    
    console.log("üîç Detailed response structure:");
    console.log("- data:", data);
    console.log("- data.data:", data?.data);
    console.log("- data.success:", data?.success);
    // Ensure we always return an array
    let result;
    if (data?.success && data?.data) {
      // Handle paginated response: {success: true, data: {users: [], pagination: {}}}
      if (Array.isArray(data.data.users)) {
        result = data.data.users;
        console.log("‚úÖ Found paginated users:", result.length);
      }
      // Handle direct array response: {success: true, data: []}
      else if (Array.isArray(data.data)) {
        result = data.data;
        console.log("‚úÖ Found direct array users:", result.length);
      } else {
        console.warn("‚ö†Ô∏è data.data is not array or users object:", data.data);
        result = [];
      }
    } else if (Array.isArray(data)) {
      result = data;
      console.log("‚úÖ Found raw array users:", result.length);
    } else {
      console.warn("‚ö†Ô∏è Unexpected getUsers response format:", data);
      result = [];
    }
    
    console.log("üîç api.getUsers() final result:", { 
      type: typeof result, 
      isArray: Array.isArray(result),
      length: result?.length || 'no length'
    });
    return result;
  }

  async createUser(userData) {
    return await this.request('/users', {
      method: 'POST',
      body: JSON.stringify(userData)
    });
  }

  async updateUser(id, userData) {
    return await this.request(`/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(userData)
    });
  }

  async deleteUser(id) {
    return await this.request(`/users/${id}`, {
      method: 'DELETE'
    });
  }

  async changePassword({ oldPassword, newPassword }) {
    return await this.request('/change-password', {
      method: 'POST',
      body: JSON.stringify({ oldPassword, newPassword })
    });
  }

  async adminChangePassword({ userId, newPassword }) {
    return await this.request(`/users/${userId}/password`, {
      method: 'PUT',
      body: JSON.stringify({ newPassword })
    });
  }

  // Seats (Ch·ªó ng·ªìi)
  async getSeats() {
    return await this.request('/seats');
  }

  async createSeat(seatData) {
    return await this.request('/seats', {
      method: 'POST',
      body: JSON.stringify(seatData)
    });
  }

  async updateSeat(id, seatData) {
    return await this.request(`/seats/${id}`, {
      method: 'PUT',
      body: JSON.stringify(seatData)
    });
  }

  async deleteSeat(id) {
    return await this.request(`/seats/${id}`, {
      method: 'DELETE'
    });
  }

  // ==================== SCHEDULE API METHODS ====================

  // L·∫•y t·∫•t c·∫£ schedule
  async getSchedules() {
    return await this.request('/schedules');
  }

  // L·∫•y schedule ƒë√£ join th√¥ng tin user
  async fetchSchedulesFull() {
    return await this.request('/schedules/full');
  }

  // Demo L·ªãch ƒêi Ca API - S·ª≠ d·ª•ng API c√≥ s·∫µn
  // Kh√¥ng c·∫ßn t·∫°o model m·ªõi, s·ª≠ d·ª•ng demo-lichdica endpoint

  // API c≈© (gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch)
  async getDailyStatus(month, year, userId = null) {
    const params = new URLSearchParams({ month, year });
    if (userId) params.append('userId', userId);
    return await this.request(`/demo-lichdica?${params}`);
  }

  async updateDailyStatus(userId, month, year, dailyStatus) {
    return await this.request('/demo-lichdica', {
      method: 'POST',
      body: JSON.stringify({ userId, month, year, dailyStatus })
    });
  }

  async updateSingleDayStatus(userId, day, month, year, status) {
    return await this.request(`/demo-lichdica/${userId}/${day}`, {
      method: 'PUT',
      body: JSON.stringify({ month, year, status })
    });
  }

  // T·∫°o b·∫£n sao l·ªãch ƒëi ca
  async createScheduleCopy(copyData) {
    return await this.request('/schedule-copy', {
      method: 'POST',
      body: JSON.stringify(copyData)
    });
  }

  // L·∫•y b·∫£n sao l·ªãch ƒëi ca theo ID
  async getScheduleCopy(copyId) {
    return await this.request(`/schedule-copy/${copyId}`);
  }

  // T·∫°o tab m·ªõi cho l·ªãch ƒëi ca (gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch)
  async createScheduleTab(tabData) {
    return await this.request('/schedule-tabs', {
      method: 'POST',
      body: JSON.stringify(tabData)
    });
  }

  // C·∫≠p nh·∫≠t tab l·ªãch ƒëi ca (gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch)
  async updateScheduleTab(tabId, tabData) {
    return await this.request(`/schedule-tabs/${tabId}`, {
      method: 'PUT',
      body: JSON.stringify(tabData)
    });
  }

  // L·∫•y tab l·ªãch ƒëi ca theo th√°ng/nƒÉm (gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch)
  async getScheduleTabByMonth(month, year) {
    try {
      const response = await this.request('/schedule-tabs');
      if (response && response.success && response.data) {
        const existingTabs = response.data.filter(tab => 
          tab.type === "month" && 
          tab.data && 
          tab.data.month === month && 
          tab.data.year === year &&
          tab.name.includes(`DEMO L·ªãch ƒëi ca th√°ng ${month}/${year}`)
        );
        
        if (existingTabs.length > 0) {
          existingTabs.sort((a, b) => {
            const timeA = new Date(a.created_at || a.updated_at || 0);
            const timeB = new Date(b.created_at || b.updated_at || 0);
            return timeB - timeA;
          });
          return existingTabs[0];
        }
        return null;
      }
      return null;
    } catch (error) {
      console.error("‚ùå L·ªói khi t√¨m tab theo th√°ng:", error);
      return null;
    }
  }

  // C·∫≠p nh·∫≠t b·∫£n sao l·ªãch ƒëi ca
  async updateScheduleCopy(copyId, copyData) {
    return await this.request(`/schedule-copy/${copyId}`, {
      method: 'PUT',
      body: JSON.stringify(copyData)
    });
  }

         // X√≥a b·∫£n sao l·ªãch ƒëi ca
       async deleteScheduleCopy(copyId) {
         try {
           const response = await this.request(`/schedule-copy/${copyId}`, {
             method: 'DELETE'
           });
           return response;
         } catch (error) {
           console.error("‚ùå API Service: L·ªói khi x√≥a b·∫£n sao:", error);
           throw error;
         }
       }

  // X√≥a tab l·ªãch ƒëi ca
  async deleteScheduleTab(tabId) {
    return await this.request(`/schedule-tabs/${tabId}`, {
      method: 'DELETE'
    });
  }

  // L·∫•y t·∫•t c·∫£ b·∫£n sao l·ªãch ƒëi ca
  async getAllScheduleCopies() {
    return await this.request('/schedule-copy');
  }

  // L·∫•y t·∫•t c·∫£ tabs l·ªãch ƒëi ca
  async getAllScheduleTabs() {
    return await this.request('/schedule-tabs');
  }

  // L·∫•y schedule theo group
  async getScheduleByGroup(group) {
    return await this.request(`/schedules/${group}`);
  }

  // T·∫°o ho·∫∑c c·∫≠p nh·∫≠t schedule cho group
  async updateSchedule(group, data) {
    return await this.request(`/schedules/${group}`, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }

  // C·∫≠p nh·∫≠t shifts cho group
  async updateShifts(group, shifts) {
    return await this.request(`/schedules/${group}/shifts`, {
      method: 'PUT',
      body: JSON.stringify({ shifts })
    });
  }

  // C·∫≠p nh·∫≠t waiting list cho group
  async updateWaiting(group, waiting) {
    return await this.request(`/schedules/${group}/waiting`, {
      method: 'PUT',
      body: JSON.stringify({ waiting })
    });
  }

  // X√≥a schedule
  async deleteSchedule(group) {
    return await this.request(`/schedules/${group}`, {
      method: 'DELETE'
    });
  }

  // ==================== SCHEDULES THEO TH√ÅNG ====================

  // L·∫•y t·∫•t c·∫£ schedules theo th√°ng/nƒÉm
  async getSchedulesByMonth(month, year) {
    return await this.request(`/schedules-monthly/monthly/${month}/${year}`);
  }

  // L·∫•y schedule theo group v√† th√°ng/nƒÉm
  async getScheduleByGroupAndMonth(group, month, year) {
    return await this.request(`/schedules-monthly/group/${group}/${month}/${year}`);
  }

  // T·∫°o ho·∫∑c c·∫≠p nh·∫≠t schedule theo th√°ng/nƒÉm
  async saveScheduleByMonth(group, month, year, shifts, waiting) {
    return await this.request('/schedules-monthly/monthly', {
      method: 'POST',
      body: JSON.stringify({ group, month, year, shifts, waiting })
    });
  }

  // C·∫≠p nh·∫≠t shifts theo th√°ng/nƒÉm
  async updateShiftsByMonth(group, month, year, shifts) {
    return await this.request(`/schedules-monthly/shifts/${group}/${month}/${year}`, {
      method: 'PUT',
      body: JSON.stringify({ shifts })
    });
  }

  // C·∫≠p nh·∫≠t waiting theo th√°ng/nƒÉm
  async updateWaitingByMonth(group, month, year, waiting) {
    return await this.request(`/schedules-monthly/waiting/${group}/${month}/${year}`, {
      method: 'PUT',
      body: JSON.stringify({ waiting })
    });
  }

  // X√≥a schedule theo th√°ng/nƒÉm
  async deleteScheduleByMonth(group, month, year) {
    return await this.request(`/schedules-monthly/${group}/${month}/${year}`, {
      method: 'DELETE'
    });
  }

  // L·∫•y th√¥ng tin user theo userId
  async getUserById(userId) {
    return await this.request(`/users/${userId}`);
  }

  // L·∫•y danh s√°ch t·∫•t c·∫£ users ƒë·ªÉ map th√¥ng tin
  async getAllUsers() {
    const data = await this.request('/users-all');
    console.log("üîç api.getAllUsers() raw response:", { 
      type: typeof data, 
      hasData: !!data?.data,
      isArray: Array.isArray(data),
      dataIsArray: Array.isArray(data?.data),
      success: data?.success,
      error: data?.error
    });
    
    // Handle response format consistently with getUsers()
    let result;
    if (data?.success && data?.data) {
      // Handle paginated response: {success: true, data: {users: [], pagination: {}}}
      if (Array.isArray(data.data.users)) {
        result = data.data.users;
        console.log("‚úÖ getAllUsers found paginated users:", result.length);
      }
      // Handle direct array response: {success: true, data: []}
      else if (Array.isArray(data.data)) {
        result = data.data;
        console.log("‚úÖ getAllUsers found direct array users:", result.length);
      } else {
        console.warn("‚ö†Ô∏è getAllUsers data.data is not array or users object:", data.data);
        result = [];
      }
    } else if (Array.isArray(data)) {
      result = data;
      console.log("‚úÖ getAllUsers found raw array users:", result.length);
    } else {
      console.warn("‚ö†Ô∏è Unexpected getAllUsers response format:", data);
      result = [];
    }
    
    console.log("üîç api.getAllUsers() final result:", { 
      type: typeof result, 
      isArray: Array.isArray(result),
      length: result?.length || 'no length'
    });
    return result;
  }

  // X√≥a user kh·ªèi shifts c·ªßa m·ªôt nh√≥m
  async removeUserFromGroupShifts(group, userId) {
    return await this.request(`/schedules/${group}/shifts/${userId}`, {
      method: 'DELETE'
    });
  }

  // X√≥a user kh·ªèi waiting list c·ªßa m·ªôt nh√≥m
  async removeUserFromGroupWaiting(group, userId) {
    return await this.request(`/schedules/${group}/waiting/${userId}`, {
      method: 'DELETE'
    });
  }

  // Cleanup orphaned users trong schedules
  async cleanupOrphanedUsers(month = null, year = null) {
    return await this.request('/cleanup-orphaned-users', {
      method: 'POST',
      body: JSON.stringify({ month, year })
    });
  }

  // Force refresh v√† cleanup d·ªØ li·ªáu theo th√°ng/nƒÉm
  async forceRefreshSchedules(month, year) {
    return await this.request('/force-refresh-schedules', {
      method: 'POST',
      body: JSON.stringify({ month, year })
    });
  }

  // ==================== SEAT API METHODS ====================

  // API calls cho Seat (v·ªã tr√≠ ch·ªó ng·ªìi)
  async getSeatData() {
    try {
      const response = await fetch(`${this.baseURL}/api/seat`);
      const data = await response.json();
      if (data.success) {
        return data.data;
      } else {
        throw new Error(data.message || 'L·ªói khi l·∫•y d·ªØ li·ªáu seat');
      }
    } catch (error) {
      console.error('L·ªói API getSeatData:', error);
      throw error;
    }
  }

  async saveSeatData(seatData) {
    try {
      const response = await fetch(`${this.baseURL}/api/seat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(seatData),
      });
      const data = await response.json();
      if (data.success) {
        return data.data;
      } else {
        throw new Error(data.message || 'L·ªói khi l∆∞u d·ªØ li·ªáu seat');
      }
    } catch (error) {
      console.error('L·ªói API saveSeatData:', error);
      throw error;
    }
  }

  async getSeatVersion() {
    try {
      const response = await fetch(`${this.baseURL}/api/seat/version`);
      const data = await response.json();
      if (data.success) {
        return data;
      } else {
        throw new Error(data.message || 'L·ªói khi l·∫•y version seat');
      }
    } catch (error) {
      console.error('L·ªói API getSeatVersion:', error);
      throw error;
    }
  }
}

// Export singleton instance
const apiService = new ApiService();

// Export authAPI for compatibility
export { authAPI } from './authAPI';
export { apiService };

export default apiService; 